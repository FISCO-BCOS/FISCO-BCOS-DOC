# Talking about Java Contract Code

Author ： WANG Zhang ｜ FISCO BCOS Core Developer

FISCO BCOS provides SDKs in multiple languages, including Go, NodeJS, Python, and Java。The Java SDK is different from other language SDKs. When calling a contract, you need to use the contract compilation tool to generate the corresponding Java code from the source code of the Solidity contract。This Java code generated by the contract compilation tool with the same name as the Solidity contract, commonly known as the Java contract code, this article describes how to generate and use this code。

## How to Generate Java Contract Code

The contract compilation tool can generate the corresponding Java code from the Solidity source code. For details, please refer to [link below](https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/console/console.html#id10)。Before explaining how the contract compilation tool generates Java contract code, introduce the concept of contract ABI。ABI is defined as:

```
The Contract Application Binary Interface (ABI) is the standard way to interact with contracts in the Ethereum ecosystem, both from outside the blockchain and for contract-to-contract interaction.
```

ABI is the standard way to interact with contracts in the Ethereum ecosystem, including the interaction between external clients and contracts, and the interaction between contracts。More generally, ABI is a specific description of a contract interface, including a list of contract interfaces, interface names, parameter names, parameter types, return types, and so on。This description is usually in JSON format, see [ABI format details](https://solidity.readthedocs.io/en/develop/abi-spec.html#json)。In the EVM ecosystem, the Solidity compiler can generate contract ABI information。When the contract compilation tool generates Java code, compile the Solidity contract to generate ABI information, parse the ABI file, and determine the list of interfaces contained in the contract, the list of input parameter names / types of each interface, and the return type according to the description of the ABI file。Based on this information, the contract compilation tool generates an interface for the generated Java contract contract class。Specific can refer to the following examples。

```
/ / Sample contract HelloWorld.sol
pragma Solidity ^0.4.25;

contract HelloWorld {
    string name;
    function HelloWorld(){
       name = "Hello, World!";
    }
    
    function get()constant returns(string){
        return name;
    }
    function set(string n){
        name = n;
    }
}
```

HelloWorld Contract ABI:

```
[{"constant":false,"inputs":[{"name":"n","type":"string"}],"name":"set","outputs":[],"payable":false,"type":"function","stateMutability":"nonpayable"},{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"","type":"string"}],"payable":false,"type":"function","stateMutability":"view"},{"inputs":[],"type":"constructor","payable":true,"stateMutability":"payable"}]
```

The above code contains descriptions of three interfaces: set, get, and constructor(Default constructor, no parameters are handled)。For the generation of set and get interfaces, please refer to the following figure。

### set interface

![](../../../../images/articles/talking_about_java-contract-code/IMG_5743.PNG)


### get interface

![](../../../../images/articles/talking_about_java-contract-code/IMG_5744.PNG)

The resulting HelloWorld.java class:

```
// HelloWorld.java 
/ / Note: Extraneous content is omitted here, only the core interface is retained
public class HelloWorld {
    public RemoteCall<TransactionReceipt> set(String n);
    public RemoteCall<String> get();
}
```

**Set and get in HelloWorld.java class are encapsulations of HelloWorld contract get and set calls, respectively。**As can be seen from the above introduction, the contract compilation tool obtains the contract ABI information through compilation, obtains the contract interface description information by parsing the ABI content, and generates the corresponding interface for the Java class。

## Java Object Oriented

Having learned how to generate Java contract code, the next step is to explain how to invoke the contract through the generated interface。The HelloWorld contract is still used here to illustrate how to call the interface:

```
HelloWorld helloWorld;    / / Initialize HelloWorld object, omit
TransactionReceipt receipt = helloWorld.set("HelloWorld").send();    / / call the set interface
```

This gesture of invoking contracts in the Java SDK can be summarized as: operating contracts for Java objects。In this way, the user only needs to use the contract compilation tool to generate the Java contract class, all operations on the contract are based on the constructed Java contract object, no longer need to pay attention to the contract ABI, send the details of acceptance, transaction packaging encoding, decoding of the results returned and other masked details。Please refer to [Java SDK Tutorial] for specific ways to call the contract(https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/sdk/java_sdk.html)。It is worth mentioning that in certain scenarios, the object-oriented Java calling method obviously cannot meet the requirements, for example: the Java contract code cannot be generated in advance, or the transaction signing and transaction construction services need to be separated。In these scenarios, using gestures like nodejs / python sdk is more flexible。But the most flexible is that users themselves care about the overall process of transaction coding and decoding, packaging, signing, sending, retrieving, and decoding。

![](../../../../images/articles/talking_about_java-contract-code/IMG_5745.PNG)


## SUMMARY

The use of the Java SDK helps users mask the details of the encoding, signing, sending, receiving, decoding and other processes, and generate Java contract code through the previous contract ABI conversion, which can be used in multiple places at once。However, there are also users who want to be able to grasp the whole process of transaction sending, or to decouple the various processes of transaction sending in specific scenarios。In this case, the NodeJS, Python, and Go versions of the client support these details more fully, and the Java SDK will gradually open the interfaces of each module。